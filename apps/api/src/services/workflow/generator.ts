import { DeploymentPlan } from '../planner/types';

export interface WorkflowResult {
  githubWorkflow?: string;
  runnerSpec?: Record<string, any>;
  dockerfile?: string;
}

/**
 * Generate all necessary configuration files from the Deployment Plan
 */
export function generateWorkflowFiles(plan: DeploymentPlan): WorkflowResult {
  const result: WorkflowResult = {};

  // Always generate Dockerfile if using Runner or if needed for GHA
  // For now, Evolvx Runner relies on Docker
  result.dockerfile = generateDockerfile(plan);

  if (plan.provider === 'GITHUB_ACTIONS') {
    result.githubWorkflow = generateGitHubAction(plan);
  } else if (plan.provider === 'EVOLVX_RUNNER') {
    result.runnerSpec = generateRunnerSpec(plan);
  }

  return result;
}

/**
 * Generate GitHub Actions YAML
 */
function generateGitHubAction(plan: DeploymentPlan): string {
  const { framework, build, runtime } = plan;
  
  const envBlock = runtime.envVars.length > 0
    ? `env:\n${runtime.envVars.map(v => `      ${v}: \${{ secrets.${v} }}`).join('\n')}`
    : '';

  return `name: Evolvx Deploy - ${framework}

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Environment
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      ${build.steps.map(step => `
      - name: ${step.name}
        run: ${step.command}
      `).join('')}
      
      - name: Deploy to Evolvx
        uses: evolvx-ai/deploy-action@v1
        with:
          project-id: ${plan.projectId}
          api-key: \${{ secrets.EVOLVX_API_KEY }}
          build-command: "${build.steps.find(s => s.name.includes('Build'))?.command || ''}"
          start-command: "${runtime.command}"
`;
}

/**
 * Generate Evolvx Runner Spec JSON
 */
function generateRunnerSpec(plan: DeploymentPlan): Record<string, any> {
  return {
    version: '2.0',
    project_id: plan.projectId,
    framework: plan.framework,
    resources: plan.resources,
    build: {
      steps: plan.build.steps,
      output: plan.build.outputDir,
      base_image: plan.build.baseImage
    },
    runtime: {
      command: plan.runtime.command,
      port: plan.runtime.port,
      health_check: plan.runtime.healthCheckPath,
      env_vars: plan.runtime.envVars
    },
    meta: {
      generated_at: plan.generatedAt.toISOString(),
      reasoning: plan.reasoning
    }
  };
}

/**
 * Generate Dockerfile
 */
function generateDockerfile(plan: DeploymentPlan): string {
  const { build, runtime } = plan;
  const buildCmd = build.steps.find(s => s.name.includes('Build'))?.command;
  const installCmd = build.steps.find(s => s.name.includes('Install'))?.command;

  // Basic Node.js Dockerfile template for now, strictly based on plan
  // Real implementation would have templates for Python/Go based on plan.framework
  // But plan.build.baseImage tells us what to use.

  if (plan.build.baseImage.includes('node')) {
    return `# Generated by Evolvx AI
FROM ${plan.build.baseImage}

WORKDIR /app

# Install dependencies
COPY package*.json ./
${installCmd ? `RUN ${installCmd}` : 'RUN npm ci'}

# Build
COPY . .
${buildCmd ? `RUN ${buildCmd}` : ''}

# Runtime
ENV PORT=${runtime.port}
ENV NODE_ENV=production

EXPOSE ${runtime.port}

CMD ${JSON.stringify(runtime.command.split(' '))}
`;
  }
  
  // Generic fallback
  return `# Generic Dockerfile for ${plan.framework}
FROM ${plan.build.baseImage}
WORKDIR /app
COPY . .
# Add build steps here if generic
CMD ${runtime.command}
`;
}
